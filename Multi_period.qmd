---
title: Risk sharing
description: balalalbadldb
authors:
  - name: Nicholas Harbour
format: 
  html:
    embed-resources: true
    code-fold: true
    number-sections: true
    toc: true
    toc-depth: 3
    date: now
    date-modified: last-modified
    date-format: "MMMM DD, YYYY, HH:mm:ss"
jupyter: python3
---


```{python}

import numpy as np  
from scipy.optimize import minimize
from scipy.optimize import differential_evolution
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import dual_annealing
import cma
from scipy.optimize import shgo

```


We are following an example from 
```{python}

means = np.array([55,70,100])
cov_mat = np.array([[255, 50, 20],
                     [50, 121, 30],
                     [20, 30, 625]])

Omega = np.array([[0.5, 0, 0],
                  [0, 1.5, 0],
                  [0, 0, 2]])

lambda_prime = np.array([1,0.5,2])

# Initial reserve
R_0 = np.ones((1000,3))*1500


# Monte carlo simulation to generate 1000
X_samples = np.random.multivariate_normal(means, cov_mat, size=1000)  # shape (1000, 3)
X = np.transpose(X_samples)  # shape (3, 1000)

```


# First solve for A0

First we need to solve for the initial time point A0

```{python}


# Objective with penalty for constraints
def objective_penalty(params):
    a11, a12, a13, a21, a22, a23, a31, a32, a33 = params

    A = np.array([[a11, a12, a13],
                  [a21, a22, a23],
                  [a31, a32, a33]])
    
    H = A @ X

    # old
    var_sum = np.var(H)

    # new

    # Empirical estimate of E[H Hᵀ]
    EHHT = H @ H.T / H.shape[1]  # divide by number of samples
    # trace

    # expecttion of H'T
    EHT = np.mean(H, axis=1).reshape(-1, 1)  # shape (3, 1)

    tr = np.trace(lambda_prime@EHT - EHHT @ Omega)

    
    # Penalize mean constraint violations heavily
    #penalty = 1e6 * np.sum(np.abs(np.mean(H, axis=1) - means))

    # constrainnt that columns sum to 1
    col_sums = np.sum(A, axis=0)
    col_penalty = 1e6 * np.sum((col_sums - 1) ** 2)



    return -(tr) + col_penalty



# Bounds for b11, b22
#bounds = [(0, 1), (0, 1), (0, 1), 
#          (0, 1), (0, 1), (0, 1), 
#          (0, 1), (0, 1), (0, 1)]

# set no bounds
bounds = [(-20, 20)] * 9

# Run differential evolution
result = differential_evolution(objective_penalty,bounds, tol=1e-10)

A0 = result.x.reshape(3, 3)

#res = dual_annealing(objective_penalty, bounds,maxiter=50000)

#res = cma.fmin(objective_penalty, x0=[0.5]*9, sigma0=0.2)

#res = shgo(objective_penalty,bounds=[(-10, 10)] * 9)

print("Optimal parameters from differential evolution:", result.x)
print("Objective value:", result.fun)

print(f"A0 = {result.x.reshape(3, 3)}")
# check if columns sum to 1
print("Column sums:", np.sum(result.x.reshape(3, 3), axis=0))
```


Next step



```{python}


def reserve_update(A, R, X):
    """
    Update the reserve based on the current allocation A and the current reserve R.
    """
    New_reserve = np.transpose(R) - A @ X

    return New_reserve



R1 = reserve_update(A0, R_0, X)


```



```{python}

# Monte carlo simulation to generate 1000
X1_samples = np.random.multivariate_normal(means, cov_mat, size=1000)  # shape (1000, 3)
X_1 = np.transpose(X1_samples)  # shape (3, 1000)

X2_samples = np.random.multivariate_normal(means, cov_mat, size=1000)  # shape (1000, 3)
X_2 = np.transpose(X2_samples)  # shape (3, 1000)

def multi_time_objective(params):

    
    # params from A0
    a0_11, a0_12, a0_13, a0_21, a0_22, a0_23, a0_31, a0_32, a0_33 = params[:9]
    A0 = np.array([[a0_11, a0_12, a0_13],
                   [a0_21, a0_22, a0_23],
                   [a0_31, a0_32, a0_33]])
    # params for A1, A2, A3
    a1_11, a1_12, a1_13, a1_21, a1_22, a1_23, a1_31, a1_32, a1_33 = params[9:18]
    A1 = np.array([[a1_11, a1_12, a1_13],
                   [a1_21, a1_22, a1_23],
                   [a1_31, a1_32, a1_33]])



    # Calculate the trace for each time step
    H1 = A0 @ X_1
    H2 = A1 @ X_2

    # Final reserve
    R_2 = np.transpose(R_0) - H1 - H2

    # Empirical estimate of E[H Hᵀ]
    EHHT = R_2 @ R_2.T / R_2.shape[1]  # divide by number of samples
    # trace

    # expecttion of H'T
    EHT = np.mean(R_2, axis=1).reshape(-1, 1)  # shape (3, 1)


    tr = np.trace(lambda_prime@EHT - EHHT @ Omega)
    
    # Penalize mean constraint violations heavily
    #penalty = 1e6 * np.sum(np.abs(np.mean(H, axis=1) - means))

    # constrainnt that columns sum to 1
    col_sums1 = np.sum(A0, axis=0)
    col_penalty = 1e6 * np.sum((col_sums1 - 1) ** 2)

    # constrainnt that columns sum to 1
    col_sums2 = np.sum(A1, axis=0)
    col_penalty2 = 1e6 * np.sum((col_sums2 - 1) ** 2)

    return -(tr) + col_penalty + col_penalty2

# Bounds for A1, A2, A3
bounds = [(-20, 20)] * 18  # 9 parameters for each of the 3 time steps
result_multi = differential_evolution(multi_time_objective, bounds, tol=1e-10)

print("Optimal parameters from multi-time differential evolution:", result_multi.x)
print("Objective value for multi-time:", result_multi.fun)
print(f"A0 = {result_multi.x[:9].reshape(3, 3)}")  
print(f"A1 = {result_multi.x[9:18].reshape(3, 3)}")




```